## ===========================================================
## XPSfit function of Object = XPS coreline
## call the XPSmakeFit AND plot the result
## ===========================================================

#' @title XPSmodFit performs the fit of a Core Line
#' @description Provides a userfriendly interface to select a fitting algorithms to
#'   fit an XPSCoreline. Fitting algorithms are:
#'   (I) Classic algorithms: Levenberg-Marquardt, Newton and Port based on the minimization
#'     of the Squares of the Differences and handled in a more robust way (although slower)
#'     compared to (\code{nlsLM}) function.
#'   (II) Conjugate-Gradient Algorithms: General-purpose optimization based on Nelder-Mead,
#'     quasi-Newton and conjugate-gradient algorithms.
#'   (III) Pseudo Algorithms: random based algorithm (rather slow) but ensure the convergence.
#' @param Object XPSCoreLine object
#' @param plt logical, to enable plot XPSCoreLine and fit. By default is set to TRUE
#' @param \dots  further parameters to the fitting function
#' @return The Object slot \code{XPSmodFit} will be filled with the result of the
#'  calculation. All the values of the components will be update and the result
#'  will be displyed.
#' @seealso \link{nlsLM}
#' @examples
#' \dontrun{
#' 	SampData[["C1s"]] <- XPSmodFit(SampData[["C1s"]])
#' }
#' @export
#'

XPSModFit <- function(Object, plt=TRUE, ...) {
       if (is.na(match("FME", Pkgs))==TRUE || is.na(match("rootSolve", Pkgs))==TRUE){
           txt = c("Package 'FME' or Package 'rootSolve' not Installed.\n",
                   "Cannot execute Model Fitting...")
           tkmessageBox(message=txt, title="ERROR", icon="error")
           return()
       }

       import::from(FME, modFit)
       import::from(rootSolve,gradient)
       assign("gradient", gradient, envir=.GlobalEnv)

# ==============================================================
# showListParam: formatted print of a list of parameters
# ==============================================================

   showListParam <- function(lista, decimals, ParamNames){
       maxLen <- 15  #max length of the list
       ParamNames <- unlist(ParamNames)
       ParamNames <- sapply(ParamNames, function(x) encodeString(x, width=15, justify="right")) #max element width=15 and align text of list elements on the rigth
       cat("\n", ParamNames)
#--- 17 = max length of list element
       lista <- lapply(lista, function(x) round(x, digits=decimals)) #rounds the numbers of decimals
       lista <- lapply(lista, function(x) as.character(x)) # transform each list element in string
       lista <- lapply(lista, function(x) encodeString(x, width=17, justify="right")) #max element width=17 and align text of list elements on the rigth
       NN <- length(lista)
       for (ii in 1:NN){
           lista[[ii]] <- substr(lista[[ii]], 4, nchar(lista[[ii]]))  #drop the first element of the list (component identifier)
           xx <- paste(lista[[ii]], sep="", collapse="")
           xx <- paste("C", ii, ": ", xx, sep="")    #reformat component name
           cat("\n", xx)
       }
   }

# ===========================================================
# XPSmakeFit: performs the FIT on the original spectrum - background
#
#--- FitFunct() estimates the fitting function using the fit parameters. It is needed for the calculation of the residuals
#      FitFunct(XX, Param, FitExpr)
#       XX = vector of abscissas
#       Param = string containing fit parameters such as: "h1 <- 12569.234; mu1 <- 284.27;, sigma1 <- 1.56....
#       FitExpr = string describing the fitting function such as: Gauss(x, h1, mu1, sigma1)+Lorentz(x, h2, mu2, sigma2)+...
#--- FitResiduals() usinf the actual fitting parameters computes the difference between fitting function and original data
#       FitResiduals(Parms)             FitResiduals transform numerical parameters in string needed to evaluate the fitting function with FitFunct()
#       Parms = numeirc array numeric of fitting parametrs
#--- modFit() minimized the residuals between fitting function and original data modifying the fitting parameters
#       modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="Pseudo")
#       f= vectors of residuals generated by FitResiduals()
#       p= Parms vector containing the fitting parameters
#       lower= lower limit for the fitting parameters
#       upper= upper limit for the fitting parameters
#       method= string containinf the selected fitting method
#
# ===========================================================

   XPSmakeFit <- function(Object, method, ...) {
#--- data to fit: curve - baseline
 	     datafit <- data.frame(x = Object@RegionToFit$x,
 				  y = Object@RegionToFit$y - Object@Baseline$y)
#--- FitExpr generates the fit expression for each of the fitting components
#--- generates the fitting parameters
	      FitExpr <- sapply(names(Object@Components), function(x) {
		           number <- unlist(strsplit(x, "C"))[2]
		           FuncName <- slot(Object@Components[[x]],"funcName")
		           Fargs <- formalArgs(FuncName)
		           lenvar <- length(Fargs)-1
#--- add index to each of the fitting parameters
		           VarNames <- c("", rep.int(number, lenvar))
		           Fparm <- paste(Fargs,VarNames, sep="")
#--- fitting formula is the ensamble of the fitting component functions
		           funct <- paste(paste(FuncName, "(", sep=""), paste(Fparm, collapse=","),")", sep="")

#--- modify fitting functions if links on fitting parameters are present
		           if (length(Object@Components[[x]]@link) ) {
                    for (idx in seq_along(slot(Object@Components[[x]],"link"))) {
   			                  funct <- sub(Object@Components[[x]]@link[[idx]]$variable, Object@Components[[x]]@link[[idx]]$expr, funct)
                    }
   		        }
		           return(funct)
	      })

       FitExpr <- paste(FitExpr, collapse= "+")

#--- parameters values
	      Parms <- lapply(Object@Components, function(x) getParam(x, parameter="start"))
	      Ubounds <- lapply(Object@Components, function(x) getParam(x, parameter="max"))
	      Lbounds <- lapply(Object@Components, function(x) getParam(x, parameter="min"))
#--- extract names of the fitting parameters
	      ParamNames <- lapply(seq_along(Object@Components), function(x,y) paste(rownames(y[[x]]@param),x,sep=""), y = Object@Components )

       cat("\n-------------------------------------------------")
       cat("\n\n START:")
       showListParam(Parms, 3, ParamNames[[1]])
       cat("\n\n UpLim:")
       showListParam(Ubounds, 3, ParamNames[[1]])
       cat("\n\n LwLim:")
       showListParam(Lbounds, 3, ParamNames[[1]])
       cat("\n-------------------------------------------------")
       cat("\n\n")

#--- #controls if a FIX constraint is set on fitting parameters
       Ncomp <- length(Object@Components)
       for(ii in 1:Ncomp){
   	      Npar <- length(Parms[[ii]])  #Componants may have different fitting functions with different number of parameters
          for(jj in 1:Npar){
              #if FIX present => Ubound==Lbound but in modFit this does not work
              if ((Ubounds[[ii]][jj] == Lbounds[[ii]][jj]) && (jj != 3)) { #here we run on all the parameters except sigma (jj=3)
                  Ubounds[[ii]][jj] <- Parms[[ii]][jj]+Parms[[ii]][jj]/10000 #Ubound~=LBound
                  Lbounds[[ii]][jj] <- Parms[[ii]][jj]-Parms[[ii]][jj]/10000
              }
          }
       }

#--- create a sequence containing all the fitting parameters
       Parms <- unlist(Parms)
       Ubounds <- unlist(Ubounds)
       Lbounds <- unlist(Lbounds)
#--- associate the correspondent parameter names
       ParamNames <- unlist(ParamNames)
	      names(Parms) <- ParamNames
	      names(Ubounds) <- ParamNames
	      names(Lbounds) <- ParamNames
#--- create a backup of the initial parameter values valori di start: questo vettore viene poi riempito
#--- start values of parameters are updated during fitting procedure
	      tmpfit <- Parms

#--- index = vector identifying the components where a link is present on a fit paramenetr
	      index <- NULL
	      for(number in seq_along(Object@Components)) {
	          if (length(Object@Components[[number]]@link)) {
	        	     for(idx in seq_along(slot(Object@Components[[number]],"link"))) {
		                index <- c(index,Object@Components[[number]]@link[[idx]]$position)
	        	     }
	          }
	      }
#--- eliminates the parameters which are linked
	      if (! is.null(index) ) {
		        Parms <- Parms[-c(index)]
		        Ubounds <- Ubounds[-c(index)]
		        Lbounds <- Lbounds[-c(index)]
	      }

#--- ParamName: mu1 = mu of FitComp 1,   sigma3 = sigma of FitComp 3,  h5 = h of FitComp 5.
#--- generates a string of type: mu1 <- 285.34;   sigma3 <- 1.4    ecc..
	     Param <- paste(ParamNames, " <- ", Parms, " ;", sep="")

      LL <- length(datafit$x)
#spectral data decimation: extract indexes of original data to use for fitting. If mesh=2 one value is taken one is drop
      indexes <- seq(from=1, to=LL, by=mesh)
      XX <- datafit$x[indexes]
      YY <- datafit$y[indexes]


#--- evaluate the fitting function using the fitting Parameters
      FitFunct <- function(XX, Param, FitExpr) {
                          eval(parse(text=Param))  #eval creates in the .GlobalEnv the fitting parameters having the correspondent values
                          eval(parse(text="x <- XX")) # FitExpr = fit function(x) needs the whole vector XX be available
                          estimate <- eval(parse(text=FitExpr))
                          return(as.vector(estimate))
                       }

#--- estimate the residuals as difference of the FitFunction and the original spectral data
      FitResiduals <- function(Parms) { #function to be minimized by modFit
                              Param <- paste(names(Parms), " <- ", Parms, " ;", sep="") #String containing FitParam evaluated by FitFunction
                              Fitting <- FitFunct(XX, Param, FitExpr) #fitting evaluates the fitting functon using the Param
                              residuals <- (YY - Fitting)
                              return(residuals)
                       }

#--- FITTING ALGORITHMS
     if (method=="Marq") {
        if (is.na(MaxIter)) MaxIter <<- 10000
        ctrl <- list(ptol= Tolerance, maxiter=MaxIter, nprint=traceFit)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="Marq", control=ctrl)
     }
     if (method=="Newton") {
        if (is.na(MaxIter)) MaxIter <<- 10000
        ctrl <- list(ptol= Tolerance, maxiter=MaxIter, nprint=traceFit)
        cat("\n Iterations are starting please wait")
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="Newton", control=ctrl)
     }
     if (method=="Port") {
        if (is.na(MaxIter)) MaxIter <<- 200
        ctrl <- list(rel.tol=Tolerance, eval.max=200, iter.max=MaxIter, trace=traceFit)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="Port", hessian=TRUE, control=ctrl)
     }
     if (method=="Nelder-Mead") {
        if (is.na(MaxIter)) MaxIter <<- 200
        ctrl <- list(reltol=Tolerance, iter.max=MaxIter, trace=traceFit)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="Nelder-Mead", control=ctrl)
     }
     if (method=="CG") {
        if (is.na(MaxIter)) MaxIter <<- 200
        ctrl <- list(reltol=Tolerance, iter.max=MaxIter, trace=traceFit)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="CG", control=ctrl)
     }
     if (method=="BFGS") {
        if (is.na(MaxIter)) MaxIter <<- 200
        ctrl <- list(reltol=Tolerance, iter.max=MaxIter, trace=traceFit)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="BFGS", control=ctrl)
     }
     if (method=="L-BFGS-B") {
        if (is.na(MaxIter)) MaxIter <<- 200
        ctrl <- list(reltol=Tolerance, iter.max=MaxIter, trace=traceFit)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="L-BFGS-B", control=ctrl)
     }
     if (method=="SANN") {
        if (is.na(MaxIter)) MaxIter <<- 200
        if (Verbose) traceFit=1
        ctrl <- list(reltol=Tolerance, iter.max=MaxIter, trace=traceFit)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="SANN", control=ctrl)
     }
     if (method=="Pseudo") {
        if (is.na(MaxIter)) MaxIter <<- 5000
        ctrl <- list(varleft=Tolerance, numiter=MaxIter, verbose=Verbose)
        FitEstimation <- modFit(f = FitResiduals, p = Parms, lower=Lbounds, upper=Ubounds, method="Pseudo", control=ctrl)
     }

     #--- SUMMARY of fit model and PLOT FIT RESULT
     cat("\n ----Best Fit Param.----\n")
     print(FitEstimation$par)
     cat("\n -----------------------\n")

     Param <- paste(names(FitEstimation$par), " <- ", FitEstimation$par, " ;", sep="") # qui metto i parametri in una stringa che valutero' in fitFunct
     Fit <- FitFunct(datafit$x, Param, FitExpr)

	    FitParam <- FitEstimation$par
#--- Update the FitParam values in the tmpfit vector
	    for (nomi in names(FitParam) ){
		       num <- grep(nomi, ParamNames)
		       tmpfit[num] <- FitParam[nomi]
	    }
#--- if there are links modify correspondent values
	    for (idx in seq_along(Object@Components) ) {
	       for ( jj in seq_along(Object@Components[[idx]]@link) ) {
		         FUN <- Object@Components[[idx]]@link[[jj]]$FUN
		         if ( ! is.na(FUN) ) {
		            origname <- Object@Components[[idx]]@link[[jj]]$newvar # mu1
		            num <- grep(origname, names(FitParam))
		            origvalue <- FitParam[num]
		            newvalue <- Object@Components[[idx]]@link[[jj]]$value
		            value <- sapply(origvalue,FUN,newvalue)
		            names(value) <- Object@Components[[idx]]@link[[jj]]$variable
		         } else {
		            origname <- Object@Components[[idx]]@link[[jj]]$expr # sigma1
  		          num <- grep(origname, names(FitParam))
              value <- FitParam[num]
		            names(value) <- Object@Components[[idx]]@link[[jj]]$variable
		         }
#--- link[[jj]]$position indicates the position of the actual parameter in FitParam
           index <- Object@Components[[idx]]@link[[jj]]$position
           tmpfit[index] <- value
	       }
	    }
     for ( idx in seq_along(Object@Components) ) {
        num1 <- grep(idx, names(tmpfit)) # Attention: this greep for idx=1 gets h1, mu1, sigma1... but also: h10, mu10, sigma10..., h11, mu11, sigma11... ecc.
        LL=length(num1)
        num2 <- gsub("[^0-9]", "", names(tmpfit))  #separates the characters form numbers in names(tmpfit)

        for (jj in LL:1) { #run on all the elements of num1 extracted by greep and selects only those equal to idx
            if (idx!= num2[num1[jj]]) { num1 <- num1[-jj] }  #drop all the elements of num1 not equal to idx
        }

        Object@Components[[idx]] <- setParam(Object@Components[[idx]],
                                             parameter="start",
                                             value=tmpfit[num1]) # start
#--- Fit components computation
	       Object@Components[[idx]] <- Ycomponent(Object@Components[[idx]], x=Object@RegionToFit$x, y=Object@Baseline$y)
	  }
#--- update slot Fit
        Object@Fit$y <- Fit
        Object@Fit$fit <- FitEstimation
        if (plt == TRUE){
            plot(Object)
            lines(datafit$x, Fit+Object@Baseline$y, lwd = 1, col = "red")
        }
        return(Object)
   }


#===== variables =====
   FittedObject <- Object  #creates a copy of original data
   mesh <- 1
   MaxIter <- NA
   Tolerance <- 1e-9
   Verbose <- TRUE
   traceFit <- 1


#=====  MAIN =========

   MFwin <- tktoplevel()
   tkwm.title(MFwin,"XPS MODEL FITTING")
   tkwm.geometry(MFwin, "+100+50")   #position respect topleft screen corner

   MFmainGroup <- ttkframe(MFwin, borderwidth=0, padding=c(0,0,0,0) )
   tkgrid(MFmainGroup, row = 1, column = 1, padx = 0, pady = 0, sticky="w")

   MFGroup1 <- ttkframe(MFmainGroup, borderwidth=0, padding=c(0,0,0,0) )
   tkgrid(MFGroup1, row = 1, column = 1, padx = 0, pady = 0, sticky="w")

   MFFframe1 <- ttklabelframe(MFGroup1, text = "Data Decimation", borderwidth=2)
   tkgrid(MFFframe1, row = 1, column = 1, padx = 5, pady = 5, sticky="w")
   decimation <- c("default","1","2","3","4","5","6","7","8","9","10")
   DCM <- tclVar("default")
   Fobj1 <- ttkcombobox(MFFframe1, width = 15, textvariable = DCM, values = decimation)
   tkbind(Fobj1, "<<ComboboxSelected>>", function(){
                   mesh <<- (tclvalue(DCM))
                   if (mesh == "default") mesh <<- 1
                   if (mesh != "default") mesh <<- as.numeric(mesh)
                   LL <- length(Object@RegionToFit$x)
                   indices <- seq(from=1, to=LL, by=mesh)
                   XX <- Object@RegionToFit$x[indices] #if mesh > 1 data decimation
                   YY <- Object@RegionToFit$y[indices]
#                   BL <- Object@Baseline$y[indices]
                   if (plt==TRUE){
                       plot(Object)
                       points(XX, YY, type="p", pch=16, cex=0.6, col="limegreen")
                   }
              })
   tkgrid(Fobj1, row = 1, column = 1, padx = 5, pady = 5, sticky="w")

   MFFframe2 <- ttklabelframe(MFGroup1, text = "Max Iterations", borderwidth=2)
   tkgrid(MFFframe2, row = 1, column = 2, padx = 5, pady = 5, sticky="w")
   MxItr <- c("default","100","200","500","1000","3000","5000","10000")
   MXI <- tclVar("default")
   Fobj2 <- ttkcombobox(MFFframe2, width = 15, textvariable = MXI, values = MxItr)
   tkbind(Fobj2, "<<ComboboxSelected>>", function(){
                   MaxIter <<- tclvalue(MXI)
                   if (MaxIter == "default") MaxIter <<- NA
                   if (MaxIter != "default") MaxIter <<- as.numeric(MaxIter)
              })
   tkgrid(Fobj2, row = 1, column = 1, padx = 5, pady = 5, sticky="w")

   MFFframe3 <- ttklabelframe(MFGroup1, text = "Tolerance", borderwidth=2)
   tkgrid(MFFframe3, row = 1, column = 3, padx = 5, pady = 5, sticky="w")
   Tlrnc <- c("default", "1e-3","1e-4","1e-5","1e-6","1e-7","1e-8", "1e-9")
   TLR <- tclVar("default")
   Fobj3 <- ttkcombobox(MFFframe3, width = 15, textvariable = TLR, values = Tlrnc)
   tkbind(Fobj3, "<<ComboboxSelected>>", function(){
                   Tolerance <<- tclvalue(TLR)
                   if (Tolerance == "default") Tolerance <<- 1e-9
                   if (Tolerance != "default") Tolerance <<- as.numeric(Tolerance)
              })
   tkgrid(Fobj3, row = 1, column = 1, padx = 5, pady = 5, sticky="w")

   MFFframe4 <- ttklabelframe(MFGroup1, text = "Verbose", borderwidth=2)
   tkgrid(MFFframe4, row = 1, column = 4, padx = 5, pady = 5, sticky="w")
   YN <- tclVar("Yes")
   Fobj4 <- ttkcombobox(MFFframe4, width = 15, textvariable = YN, values = c("yes", "no"))
   tkbind(Fobj4, "<<ComboboxSelected>>", function(){
                   Verbose <- tclvalue(YN)
                   if (Verbose == "Yes"){
                       Verbose <<- TRUE
                       traceFit <<- 1
                   } else {
                       Verbose <<- FALSE
                       traceFit <<- -1
                   }
              })
   tkgrid(Fobj4, row = 1, column = 1, padx = 5, pady = 5, sticky="w")
#---
   txt <- paste("Decimation accelerates fits but decreases precision; \n",
                "MaxIter: 10000 for classic Algorithms; \n",
                "         150 for Nelder-Mead and CG, 500 for the other Conjugate-gradient Algorithms; \n",
                "         500 for SANN, 10000 for Pseudo Algorithm; \n",
                "Tolerance: 1e-8 is the default;", collapse="")
   tkgrid( ttklabel(MFmainGroup, text=txt), row = 2, column = 1, padx = 5, pady = 10, sticky="w")
#---
   MFFframe5 <- ttklabelframe(MFmainGroup, text = "Classic Algorithms", borderwidth=2)
   tkgrid(MFFframe5, row = 3, column = 1, padx = 5, pady = 7, sticky="w")

   LvMarkBtn <- tkbutton(MFFframe5, text="Lev.Marq.", width=12, command=function(){
                   FitModel <- "Marq"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(LvMarkBtn, row = 1, column = 1, padx = 5, pady = 5, sticky="w")

   NwtnBtn <- tkbutton(MFFframe5, text="Newton", width=12, command=function(){
                   FitModel <- "Newton"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(NwtnBtn, row = 1, column = 2, padx = 5, pady = 5, sticky="w")

   PortBtn <- tkbutton(MFFframe5, text="Port", width=12, command=function(){
                   FitModel <- "Port"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(PortBtn, row = 1, column = 3, padx = 5, pady = 5, sticky="w")
#---
   MFFframe6 <- ttklabelframe(MFmainGroup, text = "Conjugate-gradient Algorithms", borderwidth=2)
   tkgrid(MFFframe6, row = 4, column = 1, padx = 5, pady = 7, sticky="w")

   NeldMBtn <- tkbutton(MFFframe6, text="Nelder-Mead", width=12, command=function(){
                   FitModel <- "Nelder-Mead"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(NeldMBtn, row = 1, column = 1, padx = 5, pady = 5, sticky="w")

   CGBtn <- tkbutton(MFFframe6, text="Conj.Grad.", width=12, command=function(){
                   FitModel <- "CG"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(CGBtn, row = 1, column = 2, padx = 5, pady = 5, sticky="w")

   BFGSBtn <- tkbutton(MFFframe6, text="BFGS", width=12, command=function(){
                   FitModel <- "BFGS"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(BFGSBtn, row = 1, column = 3, padx = 5, pady = 5, sticky="w")

   L_BFGSBtn <- tkbutton(MFFframe6, text="L-BFGS-B", width=12, command=function(){
                   FitModel <- "L-BFGS-B"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(L_BFGSBtn, row = 1, column = 4, padx = 5, pady = 5, sticky="w")
#---
   MFFframe7 <- ttklabelframe(MFmainGroup, text = "Random Algorithms", borderwidth=2)
   tkgrid(MFFframe7, row = 5, column = 1, padx = 5, pady = 7, sticky="w")

   SannBtn <- tkbutton(MFFframe7, text="SANN", width=12, command=function(){
                   FitModel <- "SANN"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(SannBtn, row = 1, column = 1, padx = 5, pady = 5, sticky="w")

   PseudoBtn <- tkbutton(MFFframe7, text="Pseudo", width=12, command=function(){
                   FitModel <- "Pseudo"
                   FittedObject <<- XPSmakeFit(Object, FitModel,  ...)
              })
   tkgrid(PseudoBtn, row = 1, column = 2, padx = 5, pady = 5, sticky="w")
#---
   MFGroup2 <- ttkframe(MFmainGroup, borderwidth=0, padding=c(0,0,0,0) )
   tkgrid(MFGroup2, row = 6, column = 1, padx = 0, pady = 5, sticky="w")

   SaveExitBtn <- tkbutton(MFGroup2, text="SAVE & EXIT", width=12, command=function(){
                   SpectIndx <- get("activeSpectIndx", envir=.GlobalEnv)
                   activeFName <- get("activeFName", envir=.GlobalEnv)
                   FName <- get(activeFName, envir=.GlobalEnv)
                   FName[[SpectIndx]] <- FittedObject
                   assign(activeFName, FName, envir=.GlobalEnv)
                   if (plt == TRUE){
                       plot(FittedObject)
                   }
                   Object <<- FittedObject
                   tkdestroy(MFwin)
                   XPSSaveRetrieveBkp("save")
              })
   tkgrid(SaveExitBtn, row = 1, column = 1, padx = 5, pady = 5, sticky="w")

   ResetBtn <- tkbutton(MFGroup2, text="RESET", width=12, command=function(){
                   mesh <<- 1   #the default values of variables is set in the ctrl list for all the algorithms
                   MaxIter <<- NA
                   Tolerance <<- 1e-9
                   traceFit <<- 1
                   tclvalue(DCM) <- "default"
                   tclvalue(MXI) <- "default"
                   tclvalue(TLR) <- "default"
                   tclvalue(YN) <- "Yes"
                   SpectIndx <- get("activeSpectIndx", envir=.GlobalEnv)
                   activeFName <- get("activeFName", envir=.GlobalEnv)
                   FName <- get(activeFName, envir=.GlobalEnv)
                   Object <<- FName[[SpectIndx]]
                   FittedObject <<- NULL
                   if (plt == TRUE){
                       plot(Object)
                   }
              })
   tkgrid(ResetBtn, row = 1, column = 2, padx = 5, pady = 5, sticky="w")

   ExitBtn <- tkbutton(MFGroup2, text="EXIT", width=12, command=function(){
                   tkdestroy(MFwin)
                   XPSSaveRetrieveBkp("save")
              })
   tkgrid(ExitBtn, row = 1, column = 3, padx = 5, pady = 5, sticky="w")

   tkwait.window(MFwin)  #set_modal == TRUE: no other operation allowed until modFit active
   return(Object)
}
